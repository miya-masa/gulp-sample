Webpack
基本的にはモジュール管理のライブラリ

今現在
scriptタグスタイル
CommonJS(仕様)
AMDスタイル(requirejsとかね)
ES6 module (Ecmaの6がなんと策定している。いずれブラウザに実装されるかも。。。)

がある。

一番古くからあるscirptagを列挙してモジュールを追加するパターンだといろいろ問題が。
・グローバルオブジェクトの衝突
・読み込み順結構大事
・ライブラリの解決は開発者がやらなくちゃだめ。。。
・プロジェクトが大きくなると無理ぽよ。

そこでいろいろモジュール管理するライブラリが出来てきた。
CommonJS

require("module");
require("../file.js");
exports.doStuff = function(){};
module.exports = someValue;

メリット
  サーバーサイドのモジュールが再利用できる
  この書き方のモジュールがすでにいっぱいある(npm)
  シンプルで簡単
デメリット
  ブロック呼び出しはネットワーク状態が良くないと出来ない。リクエストは非同期
  複数モジュールを並行呼び出しできない

  nodeとかbrowserifyとかmodules-webmakeとかwreqがこれを実装

AMD:asynchronous require
require(["module", "../file"], function(module, file) { /* ... */ });
define("mymodule", ["dep1", "dep2"], function(d1, d2) {
  return someExportedValue;
});
複雑だけど同時に読み込んだり出来る。
require.jsとかcurlとかいろいろ

EC6でもできるぜ。
簡単だけど、ブラウザ依存あるし、このスタイルのモジュールちょっとしかない

制限なければモジュール管理スタイル使ったほうが良いよ。

通信
極端に分けると二種類
・１リクエスト１モジュール
・１リクエスト全モジュール
最適化が必要
そこでWebback

様々なモジュールをバンドルする。
css,coffee,jade,css png,less,js....

======================================================-
jsのモジュール管理
圧縮
cssのモジュール管理
coffee
jade 
その他のライブラリ
watch

方針ビルドツールでもWebPackとかBrowserifyとかで出来るものは
上に乗っかるもの優先
ビルドツール上でWebPackとか動かして足りない機能をビルドツールのプラグインで補う感じが良いかな

開発汎用系(Gulpプラグインのみ)
  watch
  即ブラウザ反映
  その高速化
  jshint
  jsbeauify

============================================================
現状整理

今まではscriptタグで好きなjsを読み込んで適用。
場合によってはhtmlに埋め込んじゃえ。

=> やがて、javascriptの重要性が認知され、それじゃ収拾がつかず。。。

●グローバル変数がぶつかる―。
●jsファイルが巨大化しすぎてこれ読み込むのキツイす。。。
●スクリプトタグ多すぎね？
●開発面倒くさい。いちいちF5おさなアカンの？
●ブラウザいくつあんだよ。スマホってなんだよ。持ってないよ。そんなに。
●コード汚すぎ。もっとこう、あるだろう。
●スパゲッティにも程がある。リファクタできねーよ、ちきしょう。
●もうJavascriptだめぽ。。。。死にたいぽよorz

こういう問題があって、いろいろなツールが整備されていきます。。。
例えば、
  ブラウザの処理の差を吸収しますよ。
  DOM操作とか非同期通信とか簡単な記述で実現できますよー => jQuery

  JavaScriptもビルドする時代、巨大なjsファイルを圧縮など。
  開発そのものを管理する基盤=> grunt、gulp

  JavaScriptもモジュール化しようよ。適切に分割して依存関係も明確にして、
  もっとわかりやすく管理しよう => requirejs、browserify、webpack

  サーバーサイドだけじゃなくJavaScript側のテストもちゃんとやろうぜ！
  フレームワーク => jasmine、Qunit、Mocha
  テストランナー => karma、JSTestDriver

  クライアント側も設計をちゃんと考えようか。MVCが簡単に実装できるように、
  フレームワークを用意しよう => Backbone.js、Angularjs

  最近ビューもクライアント側でよくやるよね。
  テンプレートエンジンほしいな => Jade、EJS

  その他、開発に便利なツールをひと通り用意しよう。
    デバッガ => firebugs、Chrome developerTools
    静的コードチェック => jshint
    フォーマッタ => jsbeautify

  明確に区切ることが出来ないけど、おおまかにこんな感じ

今回紹介するやつ。
  grunt、gulp、webpack、browserify

パッケージ(モジュール)管理とは。。。
  イメージ
    => モジュールをファイル単位に分けて、わかりやすくする。
    => 記述方法統一しなくちゃ(CommonJS、AMD)
    => 記述方法統一したけど、これどうやって動かすようにするの
    => 僕らに任せろ(nodejs,RequireJS、browserify、webpack)
    RequireJS ... 読み込み時にモジュールを判別(従来のイメージ)
    WebPack、Browserify ... 単一(又は複数)の別ファイルに吐き出し、実行時にそれを読む。 

    nodejs ... js ×CommonJS
    Browserify ... js ×CommonJS ×web
    Webpack ... js ×CommonJS、AMD とかHtmlとかCSSのパッケージングも込み

参考
http://viget.com/extend/gulp-browserify-starter-faq

CommonJSで遊ぼう

commonjsの実行環境nodejs
web用にbundleする
sourcemapする
  exorcist

まずnpmについて
node package manager

nodeで利用できるライブラリを管理する。
npm install package 

まずnodejsをインストールして、CommonJSのモジュール管理を学ぶ。

Webで使えるようにbrowserifyを使う

npm init(対話型でpackagejsonを作成する)
npm install browserify --save-dev
コマンドラインのapiも今回は使用するので
npm install browserify -g

--save-devでdevdependenciesに自動的に追加してくれる
--saveだとdependencies

devDependencies => 開発時のみに必要なモジュール類(テストライブラリや、gruntやgulpのプラグイン等)
dependencies => 実行に必要なモジュール類

さっき作ったファイルをbundle化する
browserify ~~

browserifyのパッケージ解決

./または../は相対パスでモジュールを探す

名前だけだとnode_module/名前/以下のpackage.jsonを参照し、
main属性に指定されているjsファイルを参照する

require('xyz');

で

/node_modules/xyz/

が存在する場合

/node_modules/xyz/package.json

の中身を見る
{
  "name": "xyz",
  "version": "1.2.3",
  "main": "lib/abc.js"
}

この場合、mainに指定されているのは"lib/abc.js"なので

/node_modules/xyz/lib/abc.js
が
require('xyz')
で取得できる

もしpackage.jsonがない、mainが未定義など、mainが取得できない場合は
/xyz/index.jsが利用される


もし、ライブラリの特定のファイルを読み込みたい場合

var clone = require('dat/lib/clone.js');
のようにする。(これ、相対パスじゃないから注意ね)

グローバルオブジェクトはWindowだよ

browserifyの特殊なpackage.json
browser属性
ブラウザでの実行時に参照するファイル。

main属性に指定されているのはnodeでの実行時だが、
browser属性に指定されているのはbrowser実行時

キーバリューで設定すると例えば、

"lib/foo.js":"lib/browser-foo.js"

これはrequrie('lib/foo.js')で指定された時にかわりにロードするファイル

"fs":"level-fs-browser"

fsとと指定した時にロードするパッケージ名

"winston" : false
無視するモジュール名

browserify.transform field

自動的にロードするモジュールを指定する

  "browserify": {
    "transform": [ "brfs" ]
  }



=============================================
node.jsのストリーム

読み込みストリームと書き込みストリーム

ReadableStream.pipe(Writablestream).pipe(Writablestream); => 読み込みストリームを返す
読み込みストリームを書き込みストリームに流す

gulpはvinylのストリームをやりとりする
gulpのプラグインはvinylのストリームで扱われる。

browserifyを利用する時はgulp-broserifyは非推奨なので、
直接browserifyのapiを利用する必要があるが、
browserifyはvinylのストリームを扱わないので、
gulpに引き継ぐときは一度vinylのストリームに変換する(WriteStream)を挟む必要がある

var gulp = require('gulp');
var gutil = require('gulp-util');
var source = require('vinyl-source-stream');
var watchify = require('watchify');
var browserify = require('browserify');

gulp.task('watch', function() {
  var bundler = watchify(browserify('src/index.js', watchify.args));

  // Optionally, you can apply transforms
  // and other configuration options on the
  // bundler just as you would with browserify
  bundler.transform('brfs');

  bundler.on('update', rebundle);

  function rebundle() {
    return bundler.bundle()
      // log errors if they happen
      .on('error', gutil.log.bind(gutil, 'Browserify Error'))
     //####################ここで、bundle.jsをvinylのWriteStreamにする
      .pipe(source('bundle.js'))
      //すると、pipeでつないでgulp.destに渡すことが出来るよ
      .pipe(gulp.dest('./dist'));
  }

  return rebundle();
});
=====説明の流れ
 今のクライアントサイドの全体像
 ビルドシステムとは
 モジュール管理とは
  CommonJSとは
  nodejsとは
  npmとは
    scripts npm ~ に対応するコマンドをマッピング

=====チュートリアルの流れ
１．プロジェクトの作成
  nodeのインストール
  プロジェクトディレクトリの作成
  mkdir gulp-start
  git init
  npm init
    パッケージJSONの簡単な説明
  スクリプトの作成
    mkdir app\scripts
    main.jsを作成して、console.log("Hello World");
    foo.jsを作成してCommonJSを知る
  cliのgulpをインストール
  npm install gulp -g
  ローカルにgulpのインストール
  npm install gulp --save-dev
    ここでdevDependencyとDependencyの説明
  gulpのHelloWorld
======gulpfile.js
var gulp = require('gulp');

gulp.task('default', function() {
    console.log('Hello World!!!');
});
======


２．実際にビルドしてみる
  ディレクトリ構成
  google-webstarter-kitの構成を参考にする
  ROOT/app/scripts
  ROOT/app/styles
  ROOT/app/fonts
  ROOT/app/images
  ROOT/app/dist
  プロジェクト直下に
  .gitignore
  .jshintrc
  gulpfile.js
  package.json
  dist以下が成果物
  app以下がソースコード
  app/main.jsを作成
  app/index.htmlを作成
  gulpfile.jsを作成
  圧縮するために
  まず、scripts以下のソースコードを圧縮してdist/scripts以下に移動

